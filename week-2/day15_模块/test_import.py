"""
测试自定义模块导入
"""

# 自定义模块被其他模块导入时，其中的可执行语句会立即执行！！
import a


import sys
import os

# 导入系统模块会发现，并没有执行操作。因为系统模块中，并没有立即执行的可执行语句
import time

# 内存中如果成功导入模块，遇到同名模块，就不会再进行导入，只会用已经导入的模块

# 如何在导入模块的时候，不执行其中的可执行语句？？
# python 中提供了一种 判断自定义模块是属于开发阶段还是使用阶段。当处于开发阶段，可执行语句会自动执行，而当属于调用使用阶段，就不会执行。

#__name__ ← 用这个内嵌变量来进行判断

# 将已脚本方式运行时，他的值是固定字符串: __main__
# 以导入方式运行时，就是本模块的名字 假设模块是time ，那么__name__ = time

print(a.b)
a.f()

# 内置路径中：安装路径下，lib
# sys 属于内置包， sys.path 是一个路径的列表 , 当导入模块时，如果不存在与内置源码中，或者在lib下找不到，就会到sys.path这个路径列表中，每个路径都寻找一次。如果都找不到则报错
# 所以如果模块在奇异路径，就需要将该路径添加到sys.path 中

# sys.path.append(r"/User/123") # r代表字符串中的转义字符都不进行自动转义，按原始输出
# print(sys.path)

# 使用相对路径找到b.py , 因为使用绝对路径的话，就写死了

print(__file__)  # __file__输出当前文件的绝对路径

# 使用os模块获取一个路径的父路径
dir = os.path.dirname(__file__)
#print(dir + r'/aa')

sys.path.append(dir + r'/ceshi')

print(sys.path)

import b

b.test()

# 测试函数
def main():
    pass

# 可以快速生成 这样就可以将测试功能，写到main函数中去，这样在导入该模块的时候，就不会执行main函数。自动屏蔽掉了测试功能
if __name__ == '__main__':
    main()

