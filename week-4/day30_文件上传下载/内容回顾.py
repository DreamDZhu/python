# tcp 协议的多人多次通信
    # 和一个人通信说多句话
    # 和一个人聊完再和其他人聊
    # socket() 默认TCP 连接的Server 。
    # bind 绑定一个ip 和 端口
    # listen 监听，代表socket 服务的开启
    # accept 等，到有客户端来访问和客户端建立连接
    # send 直接通过消息连接来发送消息，不需要写地址
    # recv 只接收消息
    # connect 客户端tcp 协议的方法，与服务端建立连接
    # close 关闭服务  socket.socket().close 关闭服务  conn.close 关闭该连接


# udp 协议的多人多次通信
    # socket(type=socket.SOCK_DGRAM ) 表示UDP协议
    # bind 绑定一个ip 和 端口
    # sendto 需要写一个对方的地址
    # recvfrom 接收消息和发信地址
    # close 关闭服务  socket.socket().close 关闭服务  conn.close 关闭该连接


# 哪一个阶段会阻塞？
    # input() 等待，直到用户输入enter键
    # accept 阻塞，直到客户端来和我建立完连接
    # recv 阻塞，直到收到对方发过来的消息之后
    # recvfrom 阻塞，直到收到对方发来的消息之后
    # connect 阻塞，直到连接到服务器？？


# 粘包现象？
    # 什么是粘包？
        # 多条分开发送的信息，接收方接收到发现信息粘连在一起，就是粘包现象

    # 发生在发送端： 发送间隔短，数据小，由于优化机制就合在一起了
    # 发生在接收端： 接收不及时，所以数据就在接收方的缓存端粘在一起了
    # 粘包发送的本质： TCP 协议的传输优化机制，且传输是流式传输，数据与数据之间没有边界导致

    # 如何解决粘包？
    # 自定义协议，双方自定义通信协议，根据协议规则来进行解包
    # 或者 先发送四字节的信息标记，表明数据有多长，接收方接收到信息标记后，再接收指定长度的Byte流
    # struct 模块 ，将数字转换成四字节结果，可以表示-21亿 到 + 21亿 ，最后大约是1G的文件长度



