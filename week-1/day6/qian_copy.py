# 深浅拷贝

# 赋值案例 python 中的值类型与引用类型
l1 = [1, 2, 3, [22, 33]]
l2 = l1
print(l1)
print(l2)
l1.append("666")  # 执行该操作，l1和l2都会追加666这个内容
print(l1)
print(l2)

# 浅copy 使用浅拷贝，l2会在内存中，拷贝一份l1中数据的的内存空间，l2中的数据，指向l1中数据库的内存空间。但是l2这个整体，则是创建的新的，并使用了新的内存空间
# 简单来说：浅拷贝只复制 变量本身 ，变量中的内存地址，还是指向浅拷贝目标的内存地址

l1 = [1, 2, 3, [22, 33]]
l2 = l1.copy()
#l1.append("666")
l1[-1].append(123)
print(l1, id(l1))  # [1, 2, 3, [22, 33], '666'] 4386846832
print(l2, id(l2))  # [1, 2, 3, [22, 33]] 4386939280

# 但是，将666 添加到内嵌列表中，会发现，l1和l2中的内嵌列表，都增加了666项，说明内嵌列表，指向同一块内存空间，
# 那为什么我们将0改变为了abc ，而l2 的下标0位的1却没有变呢？ 因为我们改变的是下标中指向的内存地址，而不是改变原来下标中 1 这个不可变变量值本身。当我们修改l1[0] 时，我们修改的是l1[0] 指向内存空间中的 abc ,而 l2[0] 依旧指向1的内存地址，所以从print看来，是没有变化
l1[0] = "abc"
print(l1, id(l1))  # [1, 2, 3, [22, 33], '666'] 4386846832
print(l2, id(l2))  # [1, 2, 3, [22, 33]] 4386939280

# 因为代码块缓存机制，所以发现是同一个内存地址
s1 = "abc"
print(id(l1[0]))
print(id(s1))


